/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the forth_grammer_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE forth_grammer__scan_string(const char *str, yyscan_t scanner);
extern void forth_grammer__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void forth_grammer_lex_destroy(yyscan_t scanner);
extern char* forth_grammer_get_text(yyscan_t scanner);

extern yyscan_t forth_grammer__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListStatement reverseListStatement(ListStatement l)
{
  ListStatement prev = 0;
  ListStatement tmp = 0;
  while (l)
  {
    tmp = l->liststatement_;
    l->liststatement_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListExpr reverseListExpr(ListExpr l)
{
  ListExpr prev = 0;
  ListExpr tmp = 0;
  while (l)
  {
    tmp = l->listexpr_;
    l->listexpr_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Prg prg_;
  ListStatement liststatement_;
  Statement statement_;
  Expr expr_;
  Word word_;
  Constant constant_;
  ListExpr listexpr_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, forth_grammer_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _COLON       /* : */
%token          _SEMI        /* ; */
%token          _KW_begin    /* begin */
%token          _KW_if       /* if */
%token          _KW_then     /* then */
%token          _KW_until    /* until */
%token<_string> T_ForthWord  /* ForthWord */
%token<_int>    _INTEGER_

%type <prg_> Prg
%type <liststatement_> ListStatement
%type <statement_> Statement
%type <expr_> Expr
%type <word_> Word
%type <constant_> Constant
%type <listexpr_> ListExpr

%start Prg

%%

Prg : ListStatement { $$ = make_Program($1); result->prg_ = $$; }
;
ListStatement : Statement { $$ = make_ListStatement($1, 0); }
  | Statement ListStatement { $$ = make_ListStatement($1, $2); }
;
Statement : Constant { $$ = make_Literal($1); }
  | Expr { $$ = make_Expression($1); }
  | Word { $$ = make_SinlgeWord($1); }
;
Expr : _KW_if Statement _KW_then { $$ = make_Conditional($2); }
  | _KW_begin Statement _KW_until { $$ = make_Loop($2); }
  | _COLON Word Statement _SEMI { $$ = make_Define($2, $3); }
;
Word : T_ForthWord { $$ = make_Name($1); }
;
Constant : _INTEGER_ { $$ = make_Number($1); }
;
ListExpr : Expr { $$ = make_ListExpr($1, 0); }
  | Expr ListExpr { $$ = make_ListExpr($1, $2); }
;

%%


/* Entrypoint: parse Prg from file. */
Prg pPrg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = forth_grammer__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  forth_grammer_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prg_;
  }
}

/* Entrypoint: parse Prg from string. */
Prg psPrg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = forth_grammer__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = forth_grammer__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  forth_grammer__delete_buffer(buf, scanner);
  forth_grammer_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.prg_;
  }
}



