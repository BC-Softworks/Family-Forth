/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Program    ********************/

Prg make_Program(ListStatement p1)
{
    Prg tmp = (Prg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Program!\n");
        exit(1);
    }
    tmp->kind = is_Program;
    tmp->u.program_.liststatement_ = p1;
    return tmp;
}

/********************   ListStatement    ********************/

ListStatement make_ListStatement(Statement p1, ListStatement p2)
{
    ListStatement tmp = (ListStatement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListStatement!\n");
        exit(1);
    }
    tmp->statement_ = p1;
    tmp->liststatement_ = p2;
    return tmp;
}

/********************   Literal    ********************/

Statement make_Literal(Constant p1)
{
    Statement tmp = (Statement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Literal!\n");
        exit(1);
    }
    tmp->kind = is_Literal;
    tmp->u.literal_.constant_ = p1;
    return tmp;
}

/********************   Expression    ********************/

Statement make_Expression(Expr p1)
{
    Statement tmp = (Statement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Expression!\n");
        exit(1);
    }
    tmp->kind = is_Expression;
    tmp->u.expression_.expr_ = p1;
    return tmp;
}

/********************   SinlgeWord    ********************/

Statement make_SinlgeWord(Word p1)
{
    Statement tmp = (Statement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SinlgeWord!\n");
        exit(1);
    }
    tmp->kind = is_SinlgeWord;
    tmp->u.sinlgeword_.word_ = p1;
    return tmp;
}

/********************   Conditional    ********************/

Expr make_Conditional(Statement p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Conditional!\n");
        exit(1);
    }
    tmp->kind = is_Conditional;
    tmp->u.conditional_.statement_ = p1;
    return tmp;
}

/********************   Loop    ********************/

Expr make_Loop(Statement p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Loop!\n");
        exit(1);
    }
    tmp->kind = is_Loop;
    tmp->u.loop_.statement_ = p1;
    return tmp;
}

/********************   Define    ********************/

Expr make_Define(Word p1, Statement p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Define!\n");
        exit(1);
    }
    tmp->kind = is_Define;
    tmp->u.define_.word_ = p1;
    tmp->u.define_.statement_ = p2;
    return tmp;
}

/********************   Name    ********************/

Word make_Name(ForthWord p1)
{
    Word tmp = (Word) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Name!\n");
        exit(1);
    }
    tmp->kind = is_Name;
    tmp->u.name_.forthword_ = p1;
    return tmp;
}

/********************   Number    ********************/

Constant make_Number(Integer p1)
{
    Constant tmp = (Constant) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Number!\n");
        exit(1);
    }
    tmp->kind = is_Number;
    tmp->u.number_.integer_ = p1;
    return tmp;
}

/********************   ListExpr    ********************/

ListExpr make_ListExpr(Expr p1, ListExpr p2)
{
    ListExpr tmp = (ListExpr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListExpr!\n");
        exit(1);
    }
    tmp->expr_ = p1;
    tmp->listexpr_ = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

Prg clone_Prg(Prg p)
{
  switch(p->kind)
  {
  case is_Program:
    return make_Program (clone_ListStatement(p->u.program_.liststatement_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prg!\n");
    exit(1);
  }
}

ListStatement clone_ListStatement(ListStatement liststatement)
{
  if (liststatement)
  {
    /* clone of non-empty list */
    return make_ListStatement
      ( clone_Statement(liststatement->statement_)
      , clone_ListStatement(liststatement->liststatement_)
      );
  }
  else return NULL; /* clone of empty list */
}

Statement clone_Statement(Statement p)
{
  switch(p->kind)
  {
  case is_Literal:
    return make_Literal (clone_Constant(p->u.literal_.constant_));

  case is_Expression:
    return make_Expression (clone_Expr(p->u.expression_.expr_));

  case is_SinlgeWord:
    return make_SinlgeWord (clone_Word(p->u.sinlgeword_.word_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Statement!\n");
    exit(1);
  }
}

Expr clone_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_Conditional:
    return make_Conditional (clone_Statement(p->u.conditional_.statement_));

  case is_Loop:
    return make_Loop (clone_Statement(p->u.loop_.statement_));

  case is_Define:
    return make_Define
      ( clone_Word(p->u.define_.word_)
      , clone_Statement(p->u.define_.statement_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Expr!\n");
    exit(1);
  }
}

Word clone_Word(Word p)
{
  switch(p->kind)
  {
  case is_Name:
    return make_Name (strdup(p->u.name_.forthword_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Word!\n");
    exit(1);
  }
}

Constant clone_Constant(Constant p)
{
  switch(p->kind)
  {
  case is_Number:
    return make_Number (p->u.number_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning Constant!\n");
    exit(1);
  }
}

ListExpr clone_ListExpr(ListExpr listexpr)
{
  if (listexpr)
  {
    /* clone of non-empty list */
    return make_ListExpr
      ( clone_Expr(listexpr->expr_)
      , clone_ListExpr(listexpr->listexpr_)
      );
  }
  else return NULL; /* clone of empty list */
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prg(Prg p)
{
  switch(p->kind)
  {
  case is_Program:
    free_ListStatement(p->u.program_.liststatement_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prg!\n");
    exit(1);
  }
  free(p);
}

void free_ListStatement(ListStatement liststatement)
{
  if (liststatement)
  {
    free_Statement(liststatement->statement_);
    free_ListStatement(liststatement->liststatement_);
    free(liststatement);
  }
}

void free_Statement(Statement p)
{
  switch(p->kind)
  {
  case is_Literal:
    free_Constant(p->u.literal_.constant_);
    break;

  case is_Expression:
    free_Expr(p->u.expression_.expr_);
    break;

  case is_SinlgeWord:
    free_Word(p->u.sinlgeword_.word_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Statement!\n");
    exit(1);
  }
  free(p);
}

void free_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_Conditional:
    free_Statement(p->u.conditional_.statement_);
    break;

  case is_Loop:
    free_Statement(p->u.loop_.statement_);
    break;

  case is_Define:
    free_Word(p->u.define_.word_);
    free_Statement(p->u.define_.statement_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Expr!\n");
    exit(1);
  }
  free(p);
}

void free_Word(Word p)
{
  switch(p->kind)
  {
  case is_Name:
    free(p->u.name_.forthword_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Word!\n");
    exit(1);
  }
  free(p);
}

void free_Constant(Constant p)
{
  switch(p->kind)
  {
  case is_Number:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Constant!\n");
    exit(1);
  }
  free(p);
}

void free_ListExpr(ListExpr listexpr)
{
  if (listexpr)
  {
    free_Expr(listexpr->expr_);
    free_ListExpr(listexpr->listexpr_);
    free(listexpr);
  }
}

