// File generated by the BNF Converter (bnfc 2.9.5).

package forth_parser;

/** Fold Visitor */
public abstract class FoldVisitor<R,A> implements AllVisitor<R,A> {
    public abstract R leaf(A arg);
    public abstract R combine(R x, R y, A arg);

/* Prg */
    public R visit(forth_parser.Absyn.Program p, A arg) {
      R r = leaf(arg);
      for (forth_parser.Absyn.Statement x : p.liststatement_)
      {
        r = combine(x.accept(this, arg), r, arg);
      }
      return r;
    }

/* Statement */
    public R visit(forth_parser.Absyn.Literal p, A arg) {
      R r = leaf(arg);
      r = combine(p.constant_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(forth_parser.Absyn.Expression p, A arg) {
      R r = leaf(arg);
      r = combine(p.expr_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(forth_parser.Absyn.SinlgeWord p, A arg) {
      R r = leaf(arg);
      r = combine(p.word_.accept(this, arg), r, arg);
      return r;
    }

/* Expr */
    public R visit(forth_parser.Absyn.Conditional p, A arg) {
      R r = leaf(arg);
      r = combine(p.statement_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(forth_parser.Absyn.Loop p, A arg) {
      R r = leaf(arg);
      r = combine(p.statement_.accept(this, arg), r, arg);
      return r;
    }
    public R visit(forth_parser.Absyn.Define p, A arg) {
      R r = leaf(arg);
      r = combine(p.word_.accept(this, arg), r, arg);
      r = combine(p.statement_.accept(this, arg), r, arg);
      return r;
    }

/* Word */
    public R visit(forth_parser.Absyn.Name p, A arg) {
      R r = leaf(arg);
      return r;
    }

/* Constant */
    public R visit(forth_parser.Absyn.Number p, A arg) {
      R r = leaf(arg);
      return r;
    }


}
