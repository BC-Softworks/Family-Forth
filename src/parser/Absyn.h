/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* ForthWord;

/********************   Forward Declarations    ***********************/
struct Prg_;
typedef struct Prg_ *Prg;

struct ListStatement_;
typedef struct ListStatement_ *ListStatement;

struct Statement_;
typedef struct Statement_ *Statement;

struct Expr_;
typedef struct Expr_ *Expr;

struct Word_;
typedef struct Word_ *Word;

struct Constant_;
typedef struct Constant_ *Constant;

struct ListExpr_;
typedef struct ListExpr_ *ListExpr;

/********************   Abstract Syntax Classes    ********************/

struct Prg_
{
  enum { is_Program } kind;
  union
  {
    struct { ListStatement liststatement_; } program_;
  } u;
};

Prg make_Program(ListStatement p0);

struct ListStatement_
{
  Statement statement_;
  ListStatement liststatement_;
};

ListStatement make_ListStatement(Statement p1, ListStatement p2);

struct Statement_
{
  enum { is_Literal, is_Expression, is_SinlgeWord } kind;
  union
  {
    struct { Constant constant_; } literal_;
    struct { Expr expr_; } expression_;
    struct { Word word_; } sinlgeword_;
  } u;
};

Statement make_Literal(Constant p0);
Statement make_Expression(Expr p0);
Statement make_SinlgeWord(Word p0);

struct Expr_
{
  enum { is_Conditional, is_Loop, is_Define } kind;
  union
  {
    struct { Statement statement_; } conditional_;
    struct { Statement statement_; } loop_;
    struct { Statement statement_; Word word_; } define_;
  } u;
};

Expr make_Conditional(Statement p0);
Expr make_Loop(Statement p0);
Expr make_Define(Word p0, Statement p1);

struct Word_
{
  enum { is_Name } kind;
  union
  {
    struct { ForthWord forthword_; } name_;
  } u;
};

Word make_Name(ForthWord p0);

struct Constant_
{
  enum { is_Number } kind;
  union
  {
    struct { Integer integer_; } number_;
  } u;
};

Constant make_Number(Integer p0);

struct ListExpr_
{
  Expr expr_;
  ListExpr listexpr_;
};

ListExpr make_ListExpr(Expr p1, ListExpr p2);

/***************************   Cloning   ******************************/

Prg clone_Prg(Prg p);
ListStatement clone_ListStatement(ListStatement p);
Statement clone_Statement(Statement p);
Expr clone_Expr(Expr p);
Word clone_Word(Word p);
Constant clone_Constant(Constant p);
ListExpr clone_ListExpr(ListExpr p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prg(Prg p);
void free_ListStatement(ListStatement p);
void free_Statement(Statement p);
void free_Expr(Expr p);
void free_Word(Word p);
void free_Constant(Constant p);
void free_ListExpr(ListExpr p);


#endif
